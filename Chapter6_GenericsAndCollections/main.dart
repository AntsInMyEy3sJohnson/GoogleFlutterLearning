void main() {

  // Collection transformation methods work similarly to Java's stream API
  final List<String> evenNumbersAsStrings =
  List<int>.generate(10, (index) => index)
      .where((element) => element % 2 == 0) // '.filter'
      .map((e) => e.toString())
      .toList(); // '.collect(Collectors.toList())'

  // Some useful intermediates: where(), map(), skip(), followedBy()
  // Some useful terminals: toList() / toSet() / toMap(), every(), contains(), reduce(), fold()
  final list = [1, 2, 3, 4, 5, 6];
  final product = list.reduce((a, b) => a * b);
  print(product);

  final alsoProduct =
  list.fold(2, (previousValue, element) => previousValue * element);
  print(alsoProduct);

  // Important difference between 'reduce()' and 'fold()':
  // reduce(): Type of value returned by callback must be equal to type of values in list
  // fold(): Types can be different
  final someStrings = ['A', 'AA'];
  // Doesn't compile
  //someStrings.reduce((value, element) => value.length + element.length);
  final lengthOfStrings = someStrings.skip(1).fold(someStrings.first.length,
          (int previousValue, String element) => previousValue + element.length);
  print(lengthOfStrings);

  //The following two are semantically equivalent:
  // someList.reduce(someCallBack);
  // someList.skip(1).fold(list.first, someCallBack);


  final simpleCache = SimpleCache.of(20);

  // Compile-time error -- magnitudes better than using 'dynamic' and
  // making type-related errors show up only during runtime
  // String value = simpleCache.value;

  int val1 = processValue(42);
  String val2 = processValue("FortyTwo");

  // 'Spread operator' as shortcut to insert series of values into a collection:
  // (Use null-aware spread operator '...?' if unsure about non-nullability of source)
  var list1 = [7, 8];
  var list2 = [4, 5, 6, ...list1];
  print(list2);

  // Convenient way to decide whether or not to add an element to a list: in-line if statement
  final hasCoffee = true;

  final jobs = [
    "Astronaut",
    "Race Driver",
    "Accountant",
    if (hasCoffee) "Developer"
  ];

  // Better: Use 'const' rather than 'final'
  // Enables us to create a 'const' list if the bool value appears in an if statement
  // used during the former's initialization
  const constHasCoffee = true;
  const constJobs = ["Pilot", if (constHasCoffee) "Developer"];

  // 'for' statement in list initialization
  final number = [
    0, 1, 2,
    for (var i = 3; i < 10; ++i) i // Enclosing list cannot be 'const', though
  ];
  print(number);

  // Some useful way to initialize lists:
  // Growable.
  final growableList = List<
      int>(); // --> No 'length' parameter; can increase or decrease length after initialization
  // Fixed.
  final fixedList = List<int>(
      10); // --> List cannot hold more than 10 elements, and this length is fixed
  // Filled.
  final filledList = List.filled(5,
      1); // --> Create list of given length and initialize each position with given element
  // Unmodifiable.
  final unmodifiableList = List<int>.unmodifiable(
      growableList); // --> Attempting to modify list contents results in runtime exception
  // Generated by means of given generator function.
  final generatedList = List<int>.generate(5, (int index) => index * 2);

  // Caution, when initializing an empty set, make sure to specify the type:
  Set<int> emptyIntSet1 = {}; // Yup, that's a set
  final emptyIntSet2 = <int>{}; // Also a set
  final emptyIntSetThatsActuallyAMap =
      {}; // The compiler considers this to be a map with a dynamic key-value pair
  // Spread operator works with sets, too

  final m = <int, String>{0: "John", 1: "Bob", 2: "Debby"};
  m.putIfAbsent(0, () => "Jane");
  m.putIfAbsent(5, () => "Tom");
  // Square-bracket notation can be used to insert values without checking whether or not their keys exist
  m[0] = "Johnny"; // No exception -- old value for given key will be updated

  // Some best practices...
  // Use literal initialization syntax when the default implementation is fine, i. e.:
  final l = List<int>(); // --> Bad
  final l1 = <int>[]; // --> Better

  // Caution with regards to overriding '==' and 'hashCode': If a class is not
  // immutable (i. e., it has non-final fields), neither == nor hashCode should
  // be overridden as mutable state in objects of that class will break hash-based
  // collections.

}

class Example {
  // A non-generic class can define generic methods
  void doSomething<T>(T value) {}
}

// Methods can return generic types and generic types can appear in a method's
// parameter list if the diamond operator declaring the type is appended to the
// method name
T processValue<T>(T value) {
  // do something with 'value' and return it
  return value;
}

// Just like in Java, basically
abstract class Cache<T extends num> {}

abstract class LocalCache<T extends num> extends Cache<T> {}

// This works -- a subclass has to define at least the generic types
// of its parent class, but can introduce more
abstract class CloudCache<T extends num, K extends String> extends Cache<T> {}

class SimpleCache<T> {
  final T _object;

  SimpleCache.of(T object) : _object = object;

  T get value => _object;
}
